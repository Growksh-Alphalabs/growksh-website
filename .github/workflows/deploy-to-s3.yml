name: React Auto Infra Deploy (S3 + CloudFront + Route53)

on:
  push:
    branches: [ main ]

  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment (dev or prod)"
        required: false
        default: dev
      s3_bucket:
        description: "Optional: S3 bucket to deploy to (overrides repo variable)"
        required: false
      cloudfront_distribution_id:
        description: "Optional: CloudFront distribution id to invalidate (overrides repo variable)"
        required: false
      domain_name:
        description: "Your domain (example.com)"
        required: false
      hosted_zone_id:
        description: "Route53 Hosted Zone ID"
        required: false

concurrency:
  group: deploy-react
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      DOMAIN_NAME: ${{ github.event.inputs.domain_name }}
      HOSTED_ZONE_ID: ${{ github.event.inputs.hosted_zone_id }}
      # expose workflow inputs and repo variables to steps for resolution
      INPUT_S3_BUCKET: ${{ github.event.inputs.s3_bucket }}
      INPUT_CLOUDFRONT: ${{ github.event.inputs.cloudfront_distribution_id }}
      INPUT_ENVIRONMENT: ${{ github.event.inputs.environment }}
      VARS_S3_BUCKET: ${{ vars.S3_BUCKET || '' }}
      VARS_CLOUDFRONT: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID || '' }}
      EVENT_NAME: ${{ github.event_name }}

    steps:
      - name: ✅ Checkout Repo
        uses: actions/checkout@v4

      - name: ✅ Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'

      # frontend build will run after infra is deployed so VITE envs are available

      - name: ✅ Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Determine deploy targets and environment
        id: resolve
        run: |
          echo "Event: $EVENT_NAME"
          if [ "$EVENT_NAME" = "push" ]; then
            echo "DEPLOY_ENV=dev" >> $GITHUB_ENV
            # prefer repository variable S3_BUCKET if available, else compute sanitized default
            if [ -n "$VARS_S3_BUCKET" ]; then
              echo "S3_BUCKET=$VARS_S3_BUCKET" >> $GITHUB_ENV
            else
              BUCKET_NAME=react-${{ github.repository_owner }}-${{ github.event.repository.name }}-deploy
              SANITIZED=$(echo "$BUCKET_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9.-]//g')
              echo "S3_BUCKET=$SANITIZED" >> $GITHUB_ENV
            fi
            if [ -n "$VARS_CLOUDFRONT" ]; then
              echo "CLOUDFRONT_DISTRIBUTION_ID=$VARS_CLOUDFRONT" >> $GITHUB_ENV
            fi
          else
            # manual dispatch: use input environment and optional overrides
            ENV=${INPUT_ENVIRONMENT:-dev}
            echo "DEPLOY_ENV=$ENV" >> $GITHUB_ENV
            if [ -n "$INPUT_S3_BUCKET" ]; then
              echo "S3_BUCKET=$INPUT_S3_BUCKET" >> $GITHUB_ENV
            elif [ -n "$VARS_S3_BUCKET" ]; then
              echo "S3_BUCKET=$VARS_S3_BUCKET" >> $GITHUB_ENV
            else
              BUCKET_NAME=react-${{ github.repository_owner }}-${{ github.event.repository.name }}-deploy
              SANITIZED=$(echo "$BUCKET_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9.-]//g')
              echo "S3_BUCKET=$SANITIZED" >> $GITHUB_ENV
            fi
            if [ -n "$INPUT_CLOUDFRONT" ]; then
              echo "CLOUDFRONT_DISTRIBUTION_ID=$INPUT_CLOUDFRONT" >> $GITHUB_ENV
            elif [ -n "$VARS_CLOUDFRONT" ]; then
              echo "CLOUDFRONT_DISTRIBUTION_ID=$VARS_CLOUDFRONT" >> $GITHUB_ENV
            fi
          fi
          echo "Resolved S3_BUCKET=$S3_BUCKET"
        shell: bash

      # ✅ CREATE S3 BUCKET
      - name: ✅ Create S3 Bucket
        run: |
          # Use resolved S3_BUCKET if available, otherwise compute a sanitized default
          if [ -n "$S3_BUCKET" ]; then
            SANITIZED="$S3_BUCKET"
          else
            BUCKET_NAME=react-${{ github.repository_owner }}-${{ github.event.repository.name }}-deploy
            SANITIZED=$(echo "$BUCKET_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9.-]//g')
          fi

          LEN=${#SANITIZED}
          if [ "$LEN" -lt 3 ] || [ "$LEN" -gt 63 ]; then exit 1; fi

          echo "S3_BUCKET=$SANITIZED" >> $GITHUB_ENV

          # Check if bucket already exists
          if aws s3api head-bucket --bucket "$SANITIZED" 2>/dev/null; then
            echo "Bucket already exists: $SANITIZED"
          else
            echo "Creating bucket: $SANITIZED"
            if [ "$AWS_REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$SANITIZED"
            else
              aws s3api create-bucket --bucket "$SANITIZED" --create-bucket-configuration LocationConstraint=$AWS_REGION
            fi
          fi

          # Configure website hosting
          aws s3 website s3://$SANITIZED --index-document index.html --error-document index.html

          # Allow public read access
          aws s3api put-public-access-block --bucket "$SANITIZED" \
            --public-access-block-configuration BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false

          # Set bucket policy to allow public GetObject
          POLICY=$(printf '{"Version":"2012-10-17","Statement":[{"Sid":"PublicReadGetObject","Effect":"Allow","Principal":"*","Action":"s3:GetObject","Resource":"arn:aws:s3:::%s/*"}]}' "$SANITIZED")
          aws s3api put-bucket-policy --bucket "$SANITIZED" --policy "$POLICY"

          # Verify bucket is publicly accessible
          echo "Verifying bucket is accessible..."
          sleep 2
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$SANITIZED.s3-website.$AWS_REGION.amazonaws.com/")
          echo "Bucket website endpoint HTTP status: $HTTP_CODE"

      # ✅ PACKAGE & DEPLOY INFRA (Lambda + API Gateway + DynamoDB) if present
      - name: ✅ Package & deploy infra (CloudFormation)
        run: |
          if [ -f infra/sam-template.yaml ]; then
            echo "Infra template found — installing Lambda dependencies and packaging"

            # Install Lambda dependencies for all functions that declare package.json
            for d in aws-lambda/*; do
              if [ -f "$d/package.json" ]; then
                echo "Installing dependencies in $d"
                (cd "$d" && \
                  if [ -f package-lock.json ] || [ -f npm-shrinkwrap.json ]; then \
                    npm ci; \
                  else \
                    npm install; \
                  fi)
              fi
            done

            # Ensure we have a bucket to upload packaged artifacts
            if [ -z "$S3_BUCKET" ]; then
              echo "S3_BUCKET not set — using $SANITIZED"
              echo "S3_BUCKET=$SANITIZED" >> $GITHUB_ENV
            fi

            # Package the SAM/CloudFormation template (uploads artifacts to S3)
            aws cloudformation package \
              --template-file infra/sam-template.yaml \
              --s3-bucket "$S3_BUCKET" \
              --output-template-file infra/packaged.yaml

            STACK_NAME="${{ github.repository_owner }}-${{ github.event.repository.name }}-contact"

            # If stack is in ROLLBACK_COMPLETE, delete it first
            STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "")
            if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ]; then
              echo "Stack is in ROLLBACK_COMPLETE state — deleting it first"
              aws cloudformation delete-stack --stack-name "$STACK_NAME"
              echo "Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME" 2>/dev/null || true
              sleep 5
            fi

            # Deploy the packaged template (creates/updates stack)
            if ! aws cloudformation deploy \
              --template-file infra/packaged.yaml \
              --stack-name "$STACK_NAME" \
              --capabilities CAPABILITY_IAM; then
              echo "::error::CloudFormation stack deployment failed. Fetching stack events..."
              aws cloudformation describe-stack-events \
                --stack-name "$STACK_NAME" \
                --query "StackEvents[?ResourceStatus=='CREATE_FAILED' || ResourceStatus=='UPDATE_FAILED'].{Timestamp:Timestamp,LogicalId:LogicalResourceId,Reason:ResourceStatusReason}" \
                --output table
              exit 1
            fi

            # Read outputs to wire into the frontend build
            API_URL=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='ContactApiEndpoint'].OutputValue" --output text)
            TABLE_NAME=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='ContactsTableName'].OutputValue" --output text)

            if [ -n "$API_URL" ] && [ "$API_URL" != "None" ]; then
              echo "VITE_CONTACT_API_URL=$API_URL" >> $GITHUB_ENV
            fi
            if [ -n "$TABLE_NAME" ] && [ "$TABLE_NAME" != "None" ]; then
              echo "CONTACTS_TABLE=$TABLE_NAME" >> $GITHUB_ENV
            fi
            # Read Cognito outputs (if present) and export for frontend build
            USERPOOL_ID=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolId'].OutputValue" --output text)
            CLIENT_ID=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolClientId'].OutputValue" --output text)

            if [ -n "$USERPOOL_ID" ] && [ "$USERPOOL_ID" != "None" ]; then
              echo "VITE_COGNITO_USER_POOL_ID=$USERPOOL_ID" >> $GITHUB_ENV
            fi
            if [ -n "$CLIENT_ID" ] && [ "$CLIENT_ID" != "None" ]; then
              echo "VITE_COGNITO_CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
            fi
          else
            echo "No infra/sam-template.yaml — skipping infra deploy"
          fi

      # ✅ CREATE CLOUDFRONT (FIXED)
      - name: ✅ Build frontend
        run: |
          npm ci
          # export Vite env used by the frontend: VITE_API_URL is read by the code
          # Write Vite env file consumed by the frontend build
          if [ -n "$VITE_CONTACT_API_URL" ]; then
            echo "VITE_API_URL=$VITE_CONTACT_API_URL" > .env
          else
            echo "VITE_API_URL=" > .env
          fi
          if [ -n "$VITE_COGNITO_USER_POOL_ID" ]; then
            echo "VITE_COGNITO_USER_POOL_ID=$VITE_COGNITO_USER_POOL_ID" >> .env
          fi
          if [ -n "$VITE_COGNITO_CLIENT_ID" ]; then
            echo "VITE_COGNITO_CLIENT_ID=$VITE_COGNITO_CLIENT_ID" >> .env
          fi
          npm run build

      - name: ✅ Create or reuse CloudFront distribution
        run: |
          echo "Creating or reusing CloudFront for S3 bucket: $S3_BUCKET"

          if [ -n "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
            echo "Using provided CloudFront distribution ID from secrets"
            echo "CLOUDFRONT_DISTRIBUTION_ID=${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" >> $GITHUB_ENV
          else
            echo "No CLOUDFRONT_DISTRIBUTION_ID secret provided — searching for existing distribution"
            EXISTING_DIST=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[0].DomainName=='$S3_BUCKET.s3-website.$AWS_REGION.amazonaws.com'].Id" --output text | head -1)
            
            if [ -n "$EXISTING_DIST" ] && [ "$EXISTING_DIST" != "None" ] && [ -z "$(echo "$EXISTING_DIST" | grep -E '^[A-Z0-9]+$')" ]; then
              echo "No valid existing distribution found"
              EXISTING_DIST=""
            fi

            if [ -n "$EXISTING_DIST" ]; then
              echo "Found existing CloudFront distribution: $EXISTING_DIST"
              echo "CLOUDFRONT_DISTRIBUTION_ID=$EXISTING_DIST" >> $GITHUB_ENV
            else
              echo "Creating new CloudFront distribution"
              ORIGIN="$S3_BUCKET.s3-website.$AWS_REGION.amazonaws.com"
              CALLER_REF="react-deploy-$(date +%s)"
              DIST_CONFIG=$(printf '{"CallerReference":"%s","Comment":"CI Distribution","Enabled":true,"Origins":{"Quantity":1,"Items":[{"Id":"S3WebsiteOrigin","DomainName":"%s","CustomOriginConfig":{"HTTPPort":80,"HTTPSPort":443,"OriginProtocolPolicy":"http-only"}}]},"DefaultCacheBehavior":{"TargetOriginId":"S3WebsiteOrigin","ViewerProtocolPolicy":"redirect-to-https","AllowedMethods":{"Quantity":2,"Items":["GET","HEAD"]},"ForwardedValues":{"QueryString":false,"Cookies":{"Forward":"none"}},"MinTTL":0,"DefaultTTL":86400,"MaxTTL":31536000},"CustomErrorResponses":{"Quantity":1,"Items":[{"ErrorCode":404,"ResponsePagePath":"/index.html","ResponseCode":"200"}]}}' "$CALLER_REF" "$ORIGIN")
              DIST_ID=$(aws cloudfront create-distribution --distribution-config "$DIST_CONFIG" --query "Distribution.Id" --output text)
              echo "Created CloudFront distribution: $DIST_ID"
              echo "CLOUDFRONT_DISTRIBUTION_ID=$DIST_ID" >> $GITHUB_ENV
            fi
          fi

          echo "Final CLOUDFRONT_DISTRIBUTION_ID=$(cat $GITHUB_ENV | grep CLOUDFRONT_DISTRIBUTION_ID | cut -d= -f2)"

      # ✅ DEPLOY REACT BUILD
      - name: ✅ Deploy to S3 & Invalidate Cache
        run: |
          echo "S3_BUCKET=$S3_BUCKET"
          echo "CLOUDFRONT_DISTRIBUTION_ID=$CLOUDFRONT_DISTRIBUTION_ID"

          if [ -z "$S3_BUCKET" ]; then
            echo "::error::S3_BUCKET is not set"
            exit 1
          fi

          aws s3 sync dist/ s3://$S3_BUCKET --delete

          if [ -n "$CLOUDFRONT_DISTRIBUTION_ID" ]; then
            echo "Invalidating CloudFront distribution: $CLOUDFRONT_DISTRIBUTION_ID"
            aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_DISTRIBUTION_ID --paths "/*"
          else
            echo "::warning::CLOUDFRONT_DISTRIBUTION_ID not set — skipping cache invalidation"
          fi

      # ✅ OPTIONAL DOMAIN + ROUTE53 ATTACH
      - name: ✅ Attach Domain (Optional)
        if: ${{ env.DOMAIN_NAME != '' && env.HOSTED_ZONE_ID != '' }}
        run: |
          CF_DOMAIN=$(aws cloudfront get-distribution --id $CLOUDFRONT_DISTRIBUTION_ID --query "Distribution.DomainName" --output text)

          cat <<EOF > dns.json
          {
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "$DOMAIN_NAME",
                "Type": "A",
                "AliasTarget": {
                  "HostedZoneId": "Z2FDTNDATAQYW2",
                  "DNSName": "$CF_DOMAIN",
                  "EvaluateTargetHealth": false
                }
              }
            }]
          }
          EOF

          aws route53 change-resource-record-sets \
            --hosted-zone-id $HOSTED_ZONE_ID \
            --change-batch file://dns.json

      - name: ✅ Final Output
        run: |
          echo "✅ S3 Website: http://$S3_BUCKET.s3-website.$AWS_REGION.amazonaws.com"
          echo "✅ CloudFront ID: $CLOUDFRONT_DISTRIBUTION_ID"
          echo "✅ Domain: $DOMAIN_NAME"
